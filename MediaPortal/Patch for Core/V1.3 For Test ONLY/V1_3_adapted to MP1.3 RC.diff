f993a1f40ec3b043bd85d6a31d9fe54ac39b0fda
 mediaportal/Core.cpp/DXUtil/source/DXUtil.cpp | 18 +++++++++--
 mediaportal/Core/Player/FrameGrabber.cs       | 43 +++++++++++++++++++--------
 2 files changed, 45 insertions(+), 16 deletions(-)

diff --git a/mediaportal/Core.cpp/DXUtil/source/DXUtil.cpp b/mediaportal/Core.cpp/DXUtil/source/DXUtil.cpp
index d484444..92a276e 100644
--- a/mediaportal/Core.cpp/DXUtil/source/DXUtil.cpp
+++ b/mediaportal/Core.cpp/DXUtil/source/DXUtil.cpp
@@ -24,12 +24,24 @@
 // For more details for memory leak detection see the alloctracing.h header
 #include "..\..\alloctracing.h"
 
-extern "C" __declspec(dllexport) HRESULT __stdcall VideoSurfaceToRGBSurface(IDirect3DSurface9* source, IDirect3DSurface9* dest)
-{
+extern "C" __declspec(dllexport) HRESULT __stdcall VideoSurfaceToRGBSurface(IDirect3DSurface9* source,int sourceWidth,int sourceHeight, IDirect3DSurface9* dest, int destWidth,int destHeight){
 	IDirect3DDevice9* device = NULL;
 	HRESULT hr = source->GetDevice(&device);
+		
+	RECT sourceRect;
+	sourceRect.left=0;
+	sourceRect.right=sourceWidth;
+	sourceRect.top=0;
+	sourceRect.bottom=sourceHeight;
+
+	RECT destRect;
+	destRect.left=0;
+	destRect.right=destWidth;
+	destRect.top=0;
+	destRect.bottom=destHeight;
+	
 	if(!FAILED(hr)){
-		hr = device->StretchRect(source,NULL,dest,NULL,D3DTEXF_NONE);
+		hr = device->StretchRect(source,&sourceRect,dest,&destRect,D3DTEXF_NONE);
 	}
 	//delete device;
 	return hr;
diff --git a/mediaportal/Core/Player/FrameGrabber.cs b/mediaportal/Core/Player/FrameGrabber.cs
index 43da50b..412bf79 100644
--- a/mediaportal/Core/Player/FrameGrabber.cs
+++ b/mediaportal/Core/Player/FrameGrabber.cs
@@ -35,7 +35,7 @@ namespace MediaPortal
   public class FrameGrabber
   {
     [DllImport("DXUtil.dll", PreserveSig = false, CharSet = CharSet.Auto)]
-    private static extern void VideoSurfaceToRGBSurface(IntPtr src, IntPtr dst);
+    private static extern void VideoSurfaceToRGBSurface(IntPtr src,int srcWidth,int srcHeight, IntPtr dst,int dstWidth, int dstHeight);
 
     private Surface rgbSurface = null; // surface used to hold frame grabs
     private bool grabSucceeded = false; // indicates success/failure of framegrabs
@@ -43,7 +43,9 @@ namespace MediaPortal
     private readonly object grabNotifier = new object(); // Wait/Notify object for waiting for the grab to complete
 
     private static FrameGrabber instance = null;
-
+    private int captureWidth=0;
+    private int captureHeight=0;
+	
     private FrameGrabber() {}
 
     public static FrameGrabber GetInstance()
@@ -62,29 +64,40 @@ namespace MediaPortal
     /// <returns>Returns null on failure or a Bitmap object</returns>
     public Bitmap GetCurrentImage()
     {
-      try
+		return GetCurrentImage(0, 0);
+	}
+	public Bitmap GetCurrentImage(int width,int height)
+	{
+	try
       {
         //Log.Debug("GetCurrentImage called");
 
         lock (grabNotifier)
         {
-          grabSucceeded = false;
-          grabSample = true;
+			grabSucceeded = false;
+			grabSample = true;
+			captureWidth = width;
+			captureHeight = height;
           if (!Monitor.Wait(grabNotifier, 500))
           {
             Log.Debug("FrameGrabber: Timed-out waiting for grabbed frame!");
-            return null;
+            captureWidth = 0;
+            captureHeight = 0;
+           return null;
           }
-
+          captureWidth = 0;
+          captureHeight = 0;
           if (grabSucceeded)
           {
-            using (GraphicsStream stream = SurfaceLoader.SaveToStream(ImageFileFormat.Bmp, rgbSurface))
+			int pitch;
+            using (GraphicsStream stream = rgbSurface.LockRectangle(LockFlags.Discard, out pitch))
             {
-              Bitmap b = new Bitmap(Image.FromStream(stream));
+              Bitmap b = new Bitmap(rgbSurface.Description.Width,rgbSurface.Description.Height, pitch, System.Drawing.Imaging.PixelFormat.Format32bppArgb, stream.InternalData);
 
               // IMPORTANT: Closes and disposes the stream
               // If this is not done we get a memory leak!
               stream.Close();
+			  rgbSurface.UnlockRectangle();
               return b;
             }
           }
@@ -131,21 +144,25 @@ namespace MediaPortal
       //Log.Debug("PlaneScene: grabSample is true");
       try
       {
+        if (captureWidth == 0)
+          captureWidth = width;
+        if (captureHeight == 0)
+          captureHeight = height;
         // if we havent already allocated a surface or the surface dimensions dont match
         // allocate a new surface to store the grabbed frame in
-        if (rgbSurface == null || rgbSurface.Disposed || rgbSurface.Description.Height != height ||
-            rgbSurface.Description.Width != width)
+        if (rgbSurface == null || rgbSurface.Disposed || (rgbSurface.Description.Height != height && captureHeight==0) ||
+            (rgbSurface.Description.Width != width && captureWidth==0))
         {
           Log.Debug("FrameGrabber: Creating new frame grabbing surface");
 
-          rgbSurface = GUIGraphicsContext.DX9Device.CreateRenderTarget(width, height, Format.A8R8G8B8,
+          rgbSurface = GUIGraphicsContext.DX9Device.CreateRenderTarget(captureWidth, captureHeight, Format.A8R8G8B8,
                                                                        MultiSampleType.None, 0, true);
         }
         unsafe
         {
           // copy the YUV video surface to our managed ARGB surface
           // Log.Debug("Calling VideoSurfaceToRGBSurface");
-          VideoSurfaceToRGBSurface(new IntPtr(pSurface), (IntPtr)rgbSurface.UnmanagedComPointer);
+          VideoSurfaceToRGBSurface(new IntPtr(pSurface),width,height, (IntPtr)rgbSurface.UnmanagedComPointer,captureWidth,captureHeight);
           lock (grabNotifier)
           {
             grabSample = false;
